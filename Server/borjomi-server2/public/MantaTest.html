<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>SMX WebSocket API</title>
<style>


           .code{
                background:#eeffcc;
                margin:6px;
                padding-left:6px;
           }
           .iteractive{
                background:#feffcc;
                padding:6px;
                text-align:right;
           }
           .iteractive div{
                padding-bottom:6px;
            }



html, body {
	height: 100%;
	font-family: sans-serif;
	margin: 0
}
html {
	box-sizing: border-box
}
*, :after, :before {
	box-sizing: inherit;
	
}
body {
	display: flex;
	align-items: stretch;
	flex-direction: column;
	justify-content: space-between;
	max-width: 100%;
	color: #333;
}
#header {
	flex-basis: auto;
	flex-shrink: 0;	
	text-align: center;
	background-color: antiquewhite;
	box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)
}
#footer {
	flex-basis: auto;
	flex-shrink: 0;
	padding: .8em;
	text-align: center;
	background-color: #efefef;
	box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2)
}
#main {
	display: flex;
	align-items: stretch;
	flex-basis: 0%;
	flex-direction: row;
	flex-grow: 1;
	flex-shrink: 0;
	max-width: 100%;
	overflow-y: hidden;
}
#doc {
	flex-basis: 0%;
	flex-grow: 1;
	flex-shrink: 0;
	overflow-y: auto;
	padding: 16px
}
#output {
	flex-basis: 0%;
	flex-grow: 1;
	flex-shrink: 0;
	padding: 16px;
	overflow-y: auto;
}


</style>

<script type="text/javascript">
// from utils.js


function _wrapDate(obj){

// walk trhoug all object and replcace Date with json { _dtype:'date', value:val.toISOString() }
var objToSee=[ obj ]

while (objToSee.length>0){

  obj=objToSee.pop()

  for (var key in obj)
  {
    var val=obj[key]

    if (val instanceof Date) {
      if (isNaN(val.getTime())) // invalid date case
        obj[key]={ _dtype:'date', value:'' }
      else
        obj[key]={ _dtype:'date', value: val.toISOString() }
    }if ( typeof val==='object' && val!==null ){
      objToSee.push(val)
    }

  }
  
}
}

function customJSONStringify(obj){
_wrapDate(obj)
return JSON.stringify(obj, (k,val)=>{
  if (typeof val === 'number'){
    if (isFinite(val)) return val;
    return {_dtype:'number', value: val.toString() }
  }
  return val
})
}

function customJSONparse(str,blobs=undefined){
return JSON.parse(str,function (k, v) {
  if (k === '') return v
  if (v===null) return v
  if (typeof (v) == 'object' ) {

    if ('_dtype' in v){
      switch (v._dtype){
        case 'number': return Number(v.value)
        case 'date': return new Date(v.value)
      }  
    }else if ('_blobN' in v){
      return blobs[v._blobN]
    }
  }
  
  return v
})
}


// From other common files
const ErrorCodes = {
    ConnectionClosed: -1,
    Ok: 0,
    GeneralError: 1,
    HandshakeRequired: 2,
    NotLoggedIn: 3,
    InvalidFormat: 4,
    FunctionNotFound: 5,
    InvalidParams: 6,
    NoPermission: 7
}

const MessageStatus = {
    New: 1,            // New message
    Sent: 2,           // Message was sent to executor
    Accepted: 3,       // Accepted by executor
    Processing: 4,     // Executing in process
    DoneOk: 5,         // Completed successfully
    DoneError: 6,      // Message processed, but error happened (most probably not completed)
    TimedOut: 7,       // Message hasn't been accepted or processed in time
}
</script>

<script type="text/javascript">
    var debugTextArea = null;
    function loadPage(){
        debugTextArea = document.getElementById("debugTextArea");
    }
    function debug(...messages) {
        debugTextArea.value += messages.join(' ') + "\n";
        debugTextArea.scrollTop = debugTextArea.scrollHeight;
    }
    function info(...messages) {
        debugTextArea.value += messages.join(' ') + "\n";
        debugTextArea.scrollTop = debugTextArea.scrollHeight;
    }
    function error(...messages) {
        debugTextArea.value += messages.join(' ') + "\n";
        debugTextArea.scrollTop = debugTextArea.scrollHeight;
    }
    function clearLog() {
        debugTextArea.value = ""
    }

    // function sendMessage() {
    //     var msg = document.getElementById("inputText").value;
    //     if ( websocket != null )
    //     {
    //         document.getElementById("inputText").value = "";
    //         websocket.send( msg );
    //         console.log( "string sent :", '"'+msg+'"' );
    //     }else{
    //         error("Socket is not connected");
    //     }
    // }

    function sendDataRaw(sendStr){
        if ( websocket != null )
        {
            debug("Sending:\n"+sendStr) 
            websocket.send( sendStr );
        }else{
            error("Socket is not connected");
        }
    }

    function sendDataJson(data){
        if ( websocket != null )
        {
            var sendStr = customJSONStringify(data)
            debug("Sending:\n"+sendStr) 
            websocket.send( sendStr );
        }else{
            error("Socket is not connected");
        }
    }

    var wsUri = "ws://localhost:3001";
    var websocket = null;

    function initWebSocket() {
        try {
            if (typeof MozWebSocket == 'function')
                WebSocket = MozWebSocket;
            if ( websocket && websocket.readyState == 1 )
                websocket.close();
            websocket = new WebSocket( wsUri );
            info("Connecting to", wsUri)
            websocket.onopen = function (evt) {
                info("CONNECTED");
                // onCycleConnected(evt);
            };
            websocket.onclose = function (evt) {
                info("DISCONNECTED");
                // onCycleDisconnected(evt);
            };
            websocket.onmessage = function (evt) {
                console.log( "Message received :", evt.data );
                debug( "Received:\n"+evt.data );
                onSocketMessage(evt);
            };
            websocket.onerror = function (evt) {
                if (evt.data)
                    error('ERROR: ' + evt.data);
                else
                    error('ERROR. Check MaxInspect running and WebSocketAPI enabled.');
                // onCycleError(evt);
            };
        } catch (exception) {
            error('ERROR: ' + exception);
        }
    }

    function stopWebSocket() {
        if (websocket)
            websocket.close();
    }

    function checkSocket() {
        if (websocket != null) {
            var stateStr;
            switch (websocket.readyState) {
                case 0: {
                    stateStr = "CONNECTING";
                    break;
                }
                case 1: {
                    stateStr = "OPEN";
                    break;
                }
                case 2: {
                    stateStr = "CLOSING";
                    break;
                }
                case 3: {
                    stateStr = "CLOSED";
                    break;
                }
                default: {
                    stateStr = "UNKNOWN";
                    break;
                }
            }
            info("WebSocket state = " + websocket.readyState + " ( " + stateStr + " )");
        } else {
            info("WebSocket is null");
        }
    }

    function handshake(evt) {
        sendDataJson({'function':'Handshake','version':1,'reqID':1});
    }

    function login() {
        sendDataJson({
            'function': "login",
            'username': document.getElementById("username").value,
            'password': document.getElementById("password").value
        })
    }

    function logout() {
        sendDataJson({
            'function': "logout"
        })
    }

    function getMessageStatus() {
        sendDataJson({
            'function': "getMessageAnswer",
            'messageId': Number.parseInt(document.getElementById("message_id").value),
        })
    }

    function updateMessageStatus(msgId, status) {
        sendDataJson({
            'function': "updateMessageStatus",
            'messageId': msgId,
            'status': status
        })
    }

    function setMessageAnswer(msgId, errCode, errText, answer) {
        sendDataJson({
            'function': "setMessageAnswer",
            'messageId': msgId,
            'errorCode': errCode,
            'errorText': errText,
            'answer': answer
        })
    }

    function ping() {
        sendDataJson({
            'function': "newMessage",
            'type': "ping",
            'executor': Number.parseInt(document.getElementById("ping_executor").value),
            'validForMs': 1000*60 // 1 min
        })
    }

    function onSocketMessage(evt) {
        let obj = JSON.parse(evt.data)
        if (!obj) return
        if (obj.message) onServerMessage(obj.message)
    }

    function onServerMessage(msg) {
        switch (msg.type) {
            case "ping": {
                setMessageAnswer(msg.id, ErrorCodes.Ok)
                break
            }
            default: {
                setMessageAnswer(msg.id, ErrorCodes.FunctionNotFound, `Message type "${msg.type}" is not supported by this client`)
            }
        }
    }
    
</script>

</head>

<body onload="loadPage()">

    <div id="header">
        <h1>Manta-W+ stress test</h1>
        version 1.0.0
    </div>
    
    <div id="main">
        <div id="doc">
            <div class="iteractive">
                <p>Connecting to <i>localhost:XXXX</i></p>
                <button onClick="initWebSocket();">Start</button>
                <button onClick="stopWebSocket();">Stop</button>
                <button onClick="handshake();">Handshake</button>
            </div>

            <div>&nbsp;</div>
            <div class="iteractive">
                <p>Login/Logout</p>
                Username <input type="text" id="username" /><br />
                Password <input type="text" id="password" /><br />
                <button onClick="login();">Login</button>
                <button onClick="logout();">Logout</button>
            </div>

            <div>&nbsp;</div>
            <div class="iteractive">
                <p>Message status</p>
                Message ID <input type="text" id="message_id" /><br />
                <button onClick="getMessageStatus();">Read</button>
            </div>

            <div>&nbsp;</div>
            <div class="iteractive">
                <p>Message: ping</p>
                Target Account ID (0 for server) <input type="text" id="ping_executor" /><br />
                <button onClick="ping();">Send</button>
            </div>
        </div>

        <div id="output">
            <p>
            Inptut output log:
            <span style="float: right">[ <a href="#" onClick="clearLog();">Clear</a> ]</span>
            </p>
            <textarea id="debugTextArea" style="width:100%;height:80%;"></textarea>
            
        </div>
    </div>
</body>
</html>